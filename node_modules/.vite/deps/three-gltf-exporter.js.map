{
  "version": 3,
  "sources": ["../../three-gltf-exporter/index.js"],
  "sourcesContent": ["var THREE = require( 'three' );\n/**\n * @author fernandojsg / http://fernandojsg.com\n * @author Don McCurdy / https://www.donmccurdy.com\n * @author Takahiro / https://github.com/takahirox\n */\n\nvar _GLTFExporter = (function(){\n    //------------------------------------------------------------------------------\n    //Constants\n    //------------------------------------------------------------------------------\n    var WEBGL_CONSTANTS = {\n            POINTS: 0x0000,\n            LINES: 0x0001,\n            LINE_LOOP: 0x0002,\n            LINE_STRIP: 0x0003,\n            TRIANGLES: 0x0004,\n            TRIANGLE_STRIP: 0x0005,\n            TRIANGLE_FAN: 0x0006,\n\n            UNSIGNED_BYTE: 0x1401,\n            UNSIGNED_SHORT: 0x1403,\n            FLOAT: 0x1406,\n            UNSIGNED_INT: 0x1405,\n            ARRAY_BUFFER: 0x8892,\n            ELEMENT_ARRAY_BUFFER: 0x8893,\n\n            NEAREST: 0x2600,\n            LINEAR: 0x2601,\n            NEAREST_MIPMAP_NEAREST: 0x2700,\n            LINEAR_MIPMAP_NEAREST: 0x2701,\n            NEAREST_MIPMAP_LINEAR: 0x2702,\n            LINEAR_MIPMAP_LINEAR: 0x2703\n    };\n\n    var THREE_TO_WEBGL = {\n            // @TODO Replace with computed property name [THREE.*] when available on\n            // es6\n            1003: WEBGL_CONSTANTS.NEAREST,\n            1004: WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST,\n            1005: WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR,\n            1006: WEBGL_CONSTANTS.LINEAR,\n            1007: WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST,\n            1008: WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR\n    };\n\n    var PATH_PROPERTIES = {\n            scale: 'scale',\n            position: 'translation',\n            quaternion: 'rotation',\n            morphTargetInfluences: 'weights'\n    };\n//\t------------------------------------------------------------------------------\n//\tGLTF Exporter\n//\t------------------------------------------------------------------------------\n\tfunction GLTFExporter() {}\n\n\tGLTFExporter.prototype = {\n\n\t\t\tconstructor: GLTFExporter,\n\n\t\t\t/**\n\t\t\t * Parse scenes and generate GLTF output\n\t\t\t * \n\t\t\t * @param {THREE.Scene\n\t\t\t *            or [THREE.Scenes]} input THREE.Scene or Array of\n\t\t\t *            THREE.Scenes\n\t\t\t * @param {Function}\n\t\t\t *            onDone Callback on completed\n\t\t\t * @param {Object}\n\t\t\t *            options options\n\t\t\t */\n\t\t\tparse: function ( input, onDone, options ) {\n\n\t\t\t\tvar DEFAULT_OPTIONS = {\n\t\t\t\t\t\tbinary: false,\n\t\t\t\t\t\ttrs: false,\n\t\t\t\t\t\tonlyVisible: true,\n\t\t\t\t\t\ttruncateDrawRange: true,\n\t\t\t\t\t\tembedImages: true,\n\t\t\t\t\t\tanimations: [],\n\t\t\t\t\t\tforceIndices: false,\n\t\t\t\t\t\tforcePowerOfTwoTextures: false\n\t\t\t\t};\n\n\t\t\t\toptions = Object.assign( {}, DEFAULT_OPTIONS, options );\n\n\t\t\t\tif ( options.animations.length > 0 ) {\n\n\t\t\t\t\t// Only TRS properties, and not matrices, may be targeted by\n\t\t\t\t\t// animation.\n\t\t\t\t\toptions.trs = true;\n\n\t\t\t\t}\n\n\t\t\t\tvar outputJSON = {\n\n\t\t\t\t\t\tasset: {\n\n\t\t\t\t\t\t\tversion: \"2.0\",\n\t\t\t\t\t\t\tgenerator: \"THREE.GLTFExporter\"\n\n\t\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t\t\tvar byteOffset = 0;\n\t\t\t\tvar buffers = [];\n\t\t\t\tvar pending = [];\n\t\t\t\tvar nodeMap = new Map();\n\t\t\t\tvar skins = [];\n\t\t\t\tvar extensionsUsed = {};\n\t\t\t\tvar cachedData = {\n\n\t\t\t\t\t\tattributes: new Map(),\n\t\t\t\t\t\tmaterials: new Map(),\n\t\t\t\t\t\ttextures: new Map(),\n\t\t\t\t\t\timages: new Map()\n\n\t\t\t\t};\n\n\t\t\t\tvar cachedCanvas;\n\n\t\t\t\t/**\n\t\t\t\t * Compare two arrays\n\t\t\t\t */\n\t\t\t\t/**\n\t\t\t\t * Compare two arrays\n\t\t\t\t * \n\t\t\t\t * @param {Array}\n\t\t\t\t *            array1 Array 1 to compare\n\t\t\t\t * @param {Array}\n\t\t\t\t *            array2 Array 2 to compare\n\t\t\t\t * @return {Boolean} Returns true if both arrays are equal\n\t\t\t\t */\n\t\t\t\tfunction equalArray( array1, array2 ) {\n\n\t\t\t\t\treturn ( array1.length === array2.length ) && array1.every( function ( element, index ) {\n\n\t\t\t\t\t\treturn element === array2[ index ];\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * Converts a string to an ArrayBuffer.\n\t\t\t\t * \n\t\t\t\t * @param {string}\n\t\t\t\t *            text\n\t\t\t\t * @return {ArrayBuffer}\n\t\t\t\t */\n\t\t\t\tfunction stringToArrayBuffer( text ) {\n\n\t\t\t\t\tif ( window.TextEncoder !== undefined ) {\n\n\t\t\t\t\t\treturn new TextEncoder().encode( text ).buffer;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar array = new Uint8Array( new ArrayBuffer( text.length ) );\n\n\t\t\t\t\tfor ( var i = 0, il = text.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tvar value = text.charCodeAt( i );\n\n\t\t\t\t\t\t// Replacing multi-byte character with space(0x20).\n\t\t\t\t\t\tarray[ i ] = value > 0xFF ? 0x20 : value;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn array.buffer;\n\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * Get the min and max vectors from the given attribute\n\t\t\t\t * \n\t\t\t\t * @param {THREE.BufferAttribute}\n\t\t\t\t *            attribute Attribute to find the min/max in range\n\t\t\t\t *            from start to start + count\n\t\t\t\t * @param {Integer}\n\t\t\t\t *            start\n\t\t\t\t * @param {Integer}\n\t\t\t\t *            count\n\t\t\t\t * @return {Object} Object containing the `min` and `max` values\n\t\t\t\t *         (As an array of attribute.itemSize components)\n\t\t\t\t */\n\t\t\t\tfunction getMinMax( attribute, start, count ) {\n\n\t\t\t\t\tvar output = {\n\n\t\t\t\t\t\t\tmin: new Array( attribute.itemSize ).fill( Number.POSITIVE_INFINITY ),\n\t\t\t\t\t\t\tmax: new Array( attribute.itemSize ).fill( Number.NEGATIVE_INFINITY )\n\n\t\t\t\t\t};\n\n\t\t\t\t\tfor ( var i = start; i < start + count; i ++ ) {\n\n\t\t\t\t\t\tfor ( var a = 0; a < attribute.itemSize; a ++ ) {\n\n\t\t\t\t\t\t\tvar value = attribute.array[ i * attribute.itemSize + a ];\n\t\t\t\t\t\t\toutput.min[ a ] = Math.min( output.min[ a ], value );\n\t\t\t\t\t\t\toutput.max[ a ] = Math.max( output.max[ a ], value );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn output;\n\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * Checks if image size is POT.\n\t\t\t\t * \n\t\t\t\t * @param {Image}\n\t\t\t\t *            image The image to be checked.\n\t\t\t\t * @returns {Boolean} Returns true if image size is POT.\n\t\t\t\t * \n\t\t\t\t */\n\t\t\t\tfunction isPowerOfTwo( image ) {\n\n\t\t\t\t\treturn THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height );\n\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * Checks if normal attribute values are normalized.\n\t\t\t\t * \n\t\t\t\t * @param {THREE.BufferAttribute}\n\t\t\t\t *            normal\n\t\t\t\t * @returns {Boolean}\n\t\t\t\t * \n\t\t\t\t */\n\t\t\t\tfunction isNormalizedNormalAttribute( normal ) {\n\n\t\t\t\t\tif ( cachedData.attributes.has( normal ) ) {\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar v = new THREE.Vector3();\n\n\t\t\t\t\tfor ( var i = 0, il = normal.count; i < il; i ++ ) {\n\n\t\t\t\t\t\t// 0.0005 is from glTF-validator\n\t\t\t\t\t\tif ( Math.abs( v.fromArray( normal.array, i * 3 ).length() - 1.0 ) > 0.0005 ) return false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * Creates normalized normal buffer attribute.\n\t\t\t\t * \n\t\t\t\t * @param {THREE.BufferAttribute}\n\t\t\t\t *            normal\n\t\t\t\t * @returns {THREE.BufferAttribute}\n\t\t\t\t * \n\t\t\t\t */\n\t\t\t\tfunction createNormalizedNormalAttribute( normal ) {\n\n\t\t\t\t\tif ( cachedData.attributes.has( normal ) ) {\n\n\t\t\t\t\t\treturn cachedData.attributes.get( normal );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar attribute = normal.clone();\n\n\t\t\t\t\tvar v = new THREE.Vector3();\n\n\t\t\t\t\tfor ( var i = 0, il = attribute.count; i < il; i ++ ) {\n\n\t\t\t\t\t\tv.fromArray( attribute.array, i * 3 );\n\n\t\t\t\t\t\tif ( v.x === 0 && v.y === 0 && v.z === 0 ) {\n\n\t\t\t\t\t\t\t// if values can't be normalized set (1, 0, 0)\n\t\t\t\t\t\t\tv.setX( 1.0 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tv.normalize();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tv.toArray( attribute.array, i * 3 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcachedData.attributes.set( normal, attribute );\n\n\t\t\t\t\treturn attribute;\n\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * Get the required size + padding for a buffer, rounded to the\n\t\t\t\t * next 4-byte boundary.\n\t\t\t\t * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment\n\t\t\t\t * \n\t\t\t\t * @param {Integer}\n\t\t\t\t *            bufferSize The size the original buffer.\n\t\t\t\t * @returns {Integer} new buffer size with required padding.\n\t\t\t\t * \n\t\t\t\t */\n\t\t\t\tfunction getPaddedBufferSize( bufferSize ) {\n\n\t\t\t\t\treturn Math.ceil( bufferSize / 4 ) * 4;\n\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * Returns a buffer aligned to 4-byte boundary.\n\t\t\t\t * \n\t\t\t\t * @param {ArrayBuffer}\n\t\t\t\t *            arrayBuffer Buffer to pad\n\t\t\t\t * @param {Integer}\n\t\t\t\t *            paddingByte (Optional)\n\t\t\t\t * @returns {ArrayBuffer} The same buffer if it's already\n\t\t\t\t *          aligned to 4-byte boundary or a new buffer\n\t\t\t\t */\n\t\t\t\tfunction getPaddedArrayBuffer( arrayBuffer, paddingByte ) {\n\n\t\t\t\t\tpaddingByte = paddingByte || 0;\n\n\t\t\t\t\tvar paddedLength = getPaddedBufferSize( arrayBuffer.byteLength );\n\n\t\t\t\t\tif ( paddedLength !== arrayBuffer.byteLength ) {\n\n\t\t\t\t\t\tvar array = new Uint8Array( paddedLength );\n\t\t\t\t\t\tarray.set( new Uint8Array( arrayBuffer ) );\n\n\t\t\t\t\t\tif ( paddingByte !== 0 ) {\n\n\t\t\t\t\t\t\tfor ( var i = arrayBuffer.byteLength; i < paddedLength; i ++ ) {\n\n\t\t\t\t\t\t\t\tarray[ i ] = paddingByte;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn array.buffer;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn arrayBuffer;\n\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * Serializes a userData.\n\t\t\t\t * \n\t\t\t\t * @param {THREE.Object3D|THREE.Material}\n\t\t\t\t *            object\n\t\t\t\t * @returns {Object}\n\t\t\t\t */\n\t\t\t\tfunction serializeUserData( object ) {\n\n\t\t\t\t\ttry {\n\n\t\t\t\t\t\treturn JSON.parse( JSON.stringify( object.userData ) );\n\n\t\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.GLTFExporter: userData of \\'' + object.name + '\\' ' +\n\t\t\t\t\t\t\t\t'won\\'t be serialized because of JSON.stringify error - ' + error.message );\n\n\t\t\t\t\t\treturn {};\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * Process a buffer to append to the default one.\n\t\t\t\t * \n\t\t\t\t * @param {ArrayBuffer}\n\t\t\t\t *            buffer\n\t\t\t\t * @return {Integer}\n\t\t\t\t */\n\t\t\t\tfunction processBuffer( buffer ) {\n\n\t\t\t\t\tif ( ! outputJSON.buffers ) {\n\n\t\t\t\t\t\toutputJSON.buffers = [ { byteLength: 0 } ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// All buffers are merged before export.\n\t\t\t\t\tbuffers.push( buffer );\n\n\t\t\t\t\treturn 0;\n\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * Process and generate a BufferView\n\t\t\t\t * \n\t\t\t\t * @param {THREE.BufferAttribute}\n\t\t\t\t *            attribute\n\t\t\t\t * @param {number}\n\t\t\t\t *            componentType\n\t\t\t\t * @param {number}\n\t\t\t\t *            start\n\t\t\t\t * @param {number}\n\t\t\t\t *            count\n\t\t\t\t * @param {number}\n\t\t\t\t *            target (Optional) Target usage of the BufferView\n\t\t\t\t * @return {Object}\n\t\t\t\t */\n\t\t\t\tfunction processBufferView( attribute, componentType, start, count, target ) {\n\n\t\t\t\t\tif ( ! outputJSON.bufferViews ) {\n\n\t\t\t\t\t\toutputJSON.bufferViews = [];\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Create a new dataview and dump the attribute's array into\n\t\t\t\t\t// it\n\n\t\t\t\t\tvar componentSize;\n\n\t\t\t\t\tif ( componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE ) {\n\n\t\t\t\t\t\tcomponentSize = 1;\n\n\t\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT ) {\n\n\t\t\t\t\t\tcomponentSize = 2;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tcomponentSize = 4;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar byteLength = getPaddedBufferSize( count * attribute.itemSize * componentSize );\n\t\t\t\t\tvar dataView = new DataView( new ArrayBuffer( byteLength ) );\n\t\t\t\t\tvar offset = 0;\n\n\t\t\t\t\tfor ( var i = start; i < start + count; i ++ ) {\n\n\t\t\t\t\t\tfor ( var a = 0; a < attribute.itemSize; a ++ ) {\n\n\t\t\t\t\t\t\t// @TODO Fails on InterleavedBufferAttribute, and\n\t\t\t\t\t\t\t// could probably be\n\t\t\t\t\t\t\t// optimized for normal BufferAttribute.\n\t\t\t\t\t\t\tvar value = attribute.array[ i * attribute.itemSize + a ];\n\n\t\t\t\t\t\t\tif ( componentType === WEBGL_CONSTANTS.FLOAT ) {\n\n\t\t\t\t\t\t\t\tdataView.setFloat32( offset, value, true );\n\n\t\t\t\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_INT ) {\n\n\t\t\t\t\t\t\t\tdataView.setUint32( offset, value, true );\n\n\t\t\t\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT ) {\n\n\t\t\t\t\t\t\t\tdataView.setUint16( offset, value, true );\n\n\t\t\t\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE ) {\n\n\t\t\t\t\t\t\t\tdataView.setUint8( offset, value );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\toffset += componentSize;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar gltfBufferView = {\n\n\t\t\t\t\t\t\tbuffer: processBuffer( dataView.buffer ),\n\t\t\t\t\t\t\tbyteOffset: byteOffset,\n\t\t\t\t\t\t\tbyteLength: byteLength\n\n\t\t\t\t\t};\n\n\t\t\t\t\tif ( target !== undefined ) gltfBufferView.target = target;\n\n\t\t\t\t\tif ( target === WEBGL_CONSTANTS.ARRAY_BUFFER ) {\n\n\t\t\t\t\t\t// Only define byteStride for vertex attributes.\n\t\t\t\t\t\tgltfBufferView.byteStride = attribute.itemSize * componentSize;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbyteOffset += byteLength;\n\n\t\t\t\t\toutputJSON.bufferViews.push( gltfBufferView );\n\n\t\t\t\t\t// @TODO Merge bufferViews where possible.\n\t\t\t\t\tvar output = {\n\n\t\t\t\t\t\t\tid: outputJSON.bufferViews.length - 1,\n\t\t\t\t\t\t\tbyteLength: 0\n\n\t\t\t\t\t};\n\n\t\t\t\t\treturn output;\n\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * Process and generate a BufferView from an image Blob.\n\t\t\t\t * \n\t\t\t\t * @param {Blob}\n\t\t\t\t *            blob\n\t\t\t\t * @return {Promise<Integer>}\n\t\t\t\t */\n\t\t\t\tfunction processBufferViewImage( blob ) {\n\n\t\t\t\t\tif ( ! outputJSON.bufferViews ) {\n\n\t\t\t\t\t\toutputJSON.bufferViews = [];\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn new Promise( function ( resolve ) {\n\n\t\t\t\t\t\tvar reader = new window.FileReader();\n\t\t\t\t\t\treader.readAsArrayBuffer( blob );\n\t\t\t\t\t\treader.onloadend = function () {\n\n\t\t\t\t\t\t\tvar buffer = getPaddedArrayBuffer( reader.result );\n\n\t\t\t\t\t\t\tvar bufferView = {\n\t\t\t\t\t\t\t\t\tbuffer: processBuffer( buffer ),\n\t\t\t\t\t\t\t\t\tbyteOffset: byteOffset,\n\t\t\t\t\t\t\t\t\tbyteLength: buffer.byteLength\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tbyteOffset += buffer.byteLength;\n\n\t\t\t\t\t\t\toutputJSON.bufferViews.push( bufferView );\n\n\t\t\t\t\t\t\tresolve( outputJSON.bufferViews.length - 1 );\n\n\t\t\t\t\t\t};\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * Process attribute to generate an accessor\n\t\t\t\t * \n\t\t\t\t * @param {THREE.BufferAttribute}\n\t\t\t\t *            attribute Attribute to process\n\t\t\t\t * @param {THREE.BufferGeometry}\n\t\t\t\t *            geometry (Optional) Geometry used for truncated\n\t\t\t\t *            draw range\n\t\t\t\t * @param {Integer}\n\t\t\t\t *            start (Optional)\n\t\t\t\t * @param {Integer}\n\t\t\t\t *            count (Optional)\n\t\t\t\t * @return {Integer} Index of the processed accessor on the\n\t\t\t\t *         \"accessors\" array\n\t\t\t\t */\n\t\t\t\tfunction processAccessor( attribute, geometry, start, count ) {\n\n\t\t\t\t\tvar types = {\n\n\t\t\t\t\t\t\t1: 'SCALAR',\n\t\t\t\t\t\t\t2: 'VEC2',\n\t\t\t\t\t\t\t3: 'VEC3',\n\t\t\t\t\t\t\t4: 'VEC4',\n\t\t\t\t\t\t\t16: 'MAT4'\n\n\t\t\t\t\t};\n\n\t\t\t\t\tvar componentType;\n\n\t\t\t\t\t// Detect the component type of the attribute array (float,\n\t\t\t\t\t// uint or ushort)\n\t\t\t\t\tif ( attribute.array.constructor === Float32Array ) {\n\n\t\t\t\t\t\tcomponentType = WEBGL_CONSTANTS.FLOAT;\n\n\t\t\t\t\t} else if ( attribute.array.constructor === Uint32Array ) {\n\n\t\t\t\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_INT;\n\n\t\t\t\t\t} else if ( attribute.array.constructor === Uint16Array ) {\n\n\t\t\t\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;\n\n\t\t\t\t\t} else if ( attribute.array.constructor === Uint8Array ) {\n\n\t\t\t\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthrow new Error( 'THREE.GLTFExporter: Unsupported bufferAttribute component type.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( start === undefined ) start = 0;\n\t\t\t\t\tif ( count === undefined ) count = attribute.count;\n\n\t\t\t\t\t// @TODO Indexed buffer geometry with drawRange not\n\t\t\t\t\t// supported yet\n\t\t\t\t\tif ( options.truncateDrawRange && geometry !== undefined && geometry.index === null ) {\n\n\t\t\t\t\t\tvar end = start + count;\n\t\t\t\t\t\tvar end2 = geometry.drawRange.count === Infinity\n\t\t\t\t\t\t? attribute.count\n\t\t\t\t\t\t\t\t: geometry.drawRange.start + geometry.drawRange.count;\n\n\t\t\t\t\t\tstart = Math.max( start, geometry.drawRange.start );\n\t\t\t\t\t\tcount = Math.min( end, end2 ) - start;\n\n\t\t\t\t\t\tif ( count < 0 ) count = 0;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Skip creating an accessor if the attribute doesn't have\n\t\t\t\t\t// data to export\n\t\t\t\t\tif ( count === 0 ) {\n\n\t\t\t\t\t\treturn null;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar minMax = getMinMax( attribute, start, count );\n\n\t\t\t\t\tvar bufferViewTarget;\n\n\t\t\t\t\t// If geometry isn't provided, don't infer the target usage\n\t\t\t\t\t// of the bufferView. For\n\t\t\t\t\t// animation samplers, target must not be set.\n\t\t\t\t\tif ( geometry !== undefined ) {\n\n\t\t\t\t\t\tbufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar bufferView = processBufferView( attribute, componentType, start, count, bufferViewTarget );\n\n\t\t\t\t\tvar gltfAccessor = {\n\n\t\t\t\t\t\t\tbufferView: bufferView.id,\n\t\t\t\t\t\t\tbyteOffset: bufferView.byteOffset,\n\t\t\t\t\t\t\tcomponentType: componentType,\n\t\t\t\t\t\t\tcount: count,\n\t\t\t\t\t\t\tmax: minMax.max,\n\t\t\t\t\t\t\tmin: minMax.min,\n\t\t\t\t\t\t\ttype: types[ attribute.itemSize ]\n\n\t\t\t\t\t};\n\n\t\t\t\t\tif ( ! outputJSON.accessors ) {\n\n\t\t\t\t\t\toutputJSON.accessors = [];\n\n\t\t\t\t\t}\n\n\t\t\t\t\toutputJSON.accessors.push( gltfAccessor );\n\n\t\t\t\t\treturn outputJSON.accessors.length - 1;\n\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * Process image\n\t\t\t\t * \n\t\t\t\t * @param {Image}\n\t\t\t\t *            image to process\n\t\t\t\t * @param {Integer}\n\t\t\t\t *            format of the image (e.g. THREE.RGBFormat,\n\t\t\t\t *            THREE.RGBAFormat etc)\n\t\t\t\t * @param {Boolean}\n\t\t\t\t *            flipY before writing out the image\n\t\t\t\t * @return {Integer} Index of the processed texture in the\n\t\t\t\t *         \"images\" array\n\t\t\t\t */\n\t\t\t\tfunction processImage( image, format, flipY ) {\n\n\t\t\t\t\tif ( ! cachedData.images.has( image ) ) {\n\n\t\t\t\t\t\tcachedData.images.set( image, {} );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar cachedImages = cachedData.images.get( image );\n\t\t\t\t\tvar mimeType = format === THREE.RGBAFormat ? 'image/png' : 'image/jpeg';\n\t\t\t\t\tvar key = mimeType + \":flipY/\" + flipY.toString();\n\n\t\t\t\t\tif ( cachedImages[ key ] !== undefined ) {\n\n\t\t\t\t\t\treturn cachedImages[ key ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! outputJSON.images ) {\n\n\t\t\t\t\t\toutputJSON.images = [];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar gltfImage = { mimeType: mimeType };\n\n\t\t\t\t\tif ( options.embedImages ) {\n\n\t\t\t\t\t\tvar canvas = cachedCanvas = cachedCanvas || document.createElement( 'canvas' );\n\n\t\t\t\t\t\tcanvas.width = image.width;\n\t\t\t\t\t\tcanvas.height = image.height;\n\n\t\t\t\t\t\tif ( options.forcePowerOfTwoTextures && ! isPowerOfTwo( image ) ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'GLTFExporter: Resized non-power-of-two image.', image );\n\n\t\t\t\t\t\t\tcanvas.width = THREE.Math.floorPowerOfTwo( canvas.width );\n\t\t\t\t\t\t\tcanvas.height = THREE.Math.floorPowerOfTwo( canvas.height );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar ctx = canvas.getContext( '2d' );\n\n\t\t\t\t\t\tif ( flipY === true ) {\n\n\t\t\t\t\t\t\tctx.translate( 0, canvas.height );\n\t\t\t\t\t\t\tctx.scale( 1, - 1 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tctx.drawImage( image, 0, 0, canvas.width, canvas.height );\n\n\t\t\t\t\t\tif ( options.binary === true ) {\n\n\t\t\t\t\t\t\tpending.push( new Promise( function ( resolve ) {\n\n\t\t\t\t\t\t\t\tcanvas.toBlob( function ( blob ) {\n\n\t\t\t\t\t\t\t\t\tprocessBufferViewImage( blob ).then( function ( bufferViewIndex ) {\n\n\t\t\t\t\t\t\t\t\t\tgltfImage.bufferView = bufferViewIndex;\n\n\t\t\t\t\t\t\t\t\t\tresolve();\n\n\t\t\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\t\t}, mimeType );\n\n\t\t\t\t\t\t\t} ) );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tgltfImage.uri = canvas.toDataURL( mimeType );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgltfImage.uri = image.src;\n\n\t\t\t\t\t}\n\n\t\t\t\t\toutputJSON.images.push( gltfImage );\n\n\t\t\t\t\tvar index = outputJSON.images.length - 1;\n\t\t\t\t\tcachedImages[ key ] = index;\n\n\t\t\t\t\treturn index;\n\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * Process sampler\n\t\t\t\t * \n\t\t\t\t * @param {Texture}\n\t\t\t\t *            map Texture to process\n\t\t\t\t * @return {Integer} Index of the processed texture in the\n\t\t\t\t *         \"samplers\" array\n\t\t\t\t */\n\t\t\t\tfunction processSampler( map ) {\n\n\t\t\t\t\tif ( ! outputJSON.samplers ) {\n\n\t\t\t\t\t\toutputJSON.samplers = [];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar gltfSampler = {\n\n\t\t\t\t\t\t\tmagFilter: THREE_TO_WEBGL[ map.magFilter ],\n\t\t\t\t\t\t\tminFilter: THREE_TO_WEBGL[ map.minFilter ],\n\t\t\t\t\t\t\twrapS: THREE_TO_WEBGL[ map.wrapS ],\n\t\t\t\t\t\t\twrapT: THREE_TO_WEBGL[ map.wrapT ]\n\n\t\t\t\t\t};\n\n\t\t\t\t\toutputJSON.samplers.push( gltfSampler );\n\n\t\t\t\t\treturn outputJSON.samplers.length - 1;\n\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * Process texture\n\t\t\t\t * \n\t\t\t\t * @param {Texture}\n\t\t\t\t *            map Map to process\n\t\t\t\t * @return {Integer} Index of the processed texture in the\n\t\t\t\t *         \"textures\" array\n\t\t\t\t */\n\t\t\t\tfunction processTexture( map ) {\n\n\t\t\t\t\tif ( cachedData.textures.has( map ) ) {\n\n\t\t\t\t\t\treturn cachedData.textures.get( map );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! outputJSON.textures ) {\n\n\t\t\t\t\t\toutputJSON.textures = [];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar gltfTexture = {\n\n\t\t\t\t\t\t\tsampler: processSampler( map ),\n\t\t\t\t\t\t\tsource: processImage( map.image, map.format, map.flipY )\n\n\t\t\t\t\t};\n\n\t\t\t\t\toutputJSON.textures.push( gltfTexture );\n\n\t\t\t\t\tvar index = outputJSON.textures.length - 1;\n\t\t\t\t\tcachedData.textures.set( map, index );\n\n\t\t\t\t\treturn index;\n\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * Process material\n\t\t\t\t * \n\t\t\t\t * @param {THREE.Material}\n\t\t\t\t *            material Material to process\n\t\t\t\t * @return {Integer} Index of the processed material in the\n\t\t\t\t *         \"materials\" array\n\t\t\t\t */\n\t\t\t\tfunction processMaterial( material ) {\n\n\t\t\t\t\tif ( cachedData.materials.has( material ) ) {\n\n\t\t\t\t\t\treturn cachedData.materials.get( material );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! outputJSON.materials ) {\n\n\t\t\t\t\t\toutputJSON.materials = [];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( material.isShaderMaterial ) {\n\n\t\t\t\t\t\tconsole.warn( 'GLTFExporter: THREE.ShaderMaterial not supported.' );\n\t\t\t\t\t\treturn null;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// @QUESTION Should we avoid including any attribute that\n\t\t\t\t\t// has the default value?\n\t\t\t\t\tvar gltfMaterial = {\n\n\t\t\t\t\t\t\tpbrMetallicRoughness: {}\n\n\t\t\t\t\t};\n\n\t\t\t\t\tif ( material.isMeshBasicMaterial ) {\n\n\t\t\t\t\t\tgltfMaterial.extensions = { KHR_materials_unlit: {} };\n\n\t\t\t\t\t\textensionsUsed[ 'KHR_materials_unlit' ] = true;\n\n\t\t\t\t\t} else if ( ! material.isMeshStandardMaterial ) {\n\n\t\t\t\t\t\tconsole.warn( 'GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// pbrMetallicRoughness.baseColorFactor\n\t\t\t\t\tvar color = material.color.toArray().concat( [ material.opacity ] );\n\n\t\t\t\t\tif ( ! equalArray( color, [ 1, 1, 1, 1 ] ) ) {\n\n\t\t\t\t\t\tgltfMaterial.pbrMetallicRoughness.baseColorFactor = color;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( material.isMeshStandardMaterial ) {\n\n\t\t\t\t\t\tgltfMaterial.pbrMetallicRoughness.metallicFactor = material.metalness;\n\t\t\t\t\t\tgltfMaterial.pbrMetallicRoughness.roughnessFactor = material.roughness;\n\n\t\t\t\t\t} else if ( material.isMeshBasicMaterial ) {\n\n\t\t\t\t\t\tgltfMaterial.pbrMetallicRoughness.metallicFactor = 0.0;\n\t\t\t\t\t\tgltfMaterial.pbrMetallicRoughness.roughnessFactor = 0.9;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgltfMaterial.pbrMetallicRoughness.metallicFactor = 0.5;\n\t\t\t\t\t\tgltfMaterial.pbrMetallicRoughness.roughnessFactor = 0.5;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// pbrMetallicRoughness.metallicRoughnessTexture\n\t\t\t\t\tif ( material.metalnessMap || material.roughnessMap ) {\n\n\t\t\t\t\t\tif ( material.metalnessMap === material.roughnessMap ) {\n\n\t\t\t\t\t\t\tgltfMaterial.pbrMetallicRoughness.metallicRoughnessTexture = {\n\n\t\t\t\t\t\t\t\t\tindex: processTexture( material.metalnessMap )\n\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// pbrMetallicRoughness.baseColorTexture\n\t\t\t\t\tif ( material.map ) {\n\n\t\t\t\t\t\tgltfMaterial.pbrMetallicRoughness.baseColorTexture = {\n\n\t\t\t\t\t\t\t\tindex: processTexture( material.map )\n\n\t\t\t\t\t\t};\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( material.isMeshBasicMaterial ||\n\t\t\t\t\t\t\tmaterial.isLineBasicMaterial ||\n\t\t\t\t\t\t\tmaterial.isPointsMaterial ) {\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// emissiveFactor\n\t\t\t\t\t\tvar emissive = material.emissive.clone().multiplyScalar( material.emissiveIntensity ).toArray();\n\n\t\t\t\t\t\tif ( ! equalArray( emissive, [ 0, 0, 0 ] ) ) {\n\n\t\t\t\t\t\t\tgltfMaterial.emissiveFactor = emissive;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// emissiveTexture\n\t\t\t\t\t\tif ( material.emissiveMap ) {\n\n\t\t\t\t\t\t\tgltfMaterial.emissiveTexture = {\n\n\t\t\t\t\t\t\t\t\tindex: processTexture( material.emissiveMap )\n\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// normalTexture\n\t\t\t\t\tif ( material.normalMap ) {\n\n\t\t\t\t\t\tgltfMaterial.normalTexture = {\n\n\t\t\t\t\t\t\t\tindex: processTexture( material.normalMap )\n\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tif ( material.normalScale.x !== - 1 ) {\n\n\t\t\t\t\t\t\tif ( material.normalScale.x !== material.normalScale.y ) {\n\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Normal scale components are different, ignoring Y and exporting X.' );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tgltfMaterial.normalTexture.scale = material.normalScale.x;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// occlusionTexture\n\t\t\t\t\tif ( material.aoMap ) {\n\n\t\t\t\t\t\tgltfMaterial.occlusionTexture = {\n\n\t\t\t\t\t\t\t\tindex: processTexture( material.aoMap )\n\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tif ( material.aoMapIntensity !== 1.0 ) {\n\n\t\t\t\t\t\t\tgltfMaterial.occlusionTexture.strength = material.aoMapIntensity;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// alphaMode\n\t\t\t\t\tif ( material.transparent || material.alphaTest > 0.0 ) {\n\n\t\t\t\t\t\tgltfMaterial.alphaMode = material.opacity < 1.0 ? 'BLEND' : 'MASK';\n\n\t\t\t\t\t\t// Write alphaCutoff if it's non-zero and different from\n\t\t\t\t\t\t// the default (0.5).\n\t\t\t\t\t\tif ( material.alphaTest > 0.0 && material.alphaTest !== 0.5 ) {\n\n\t\t\t\t\t\t\tgltfMaterial.alphaCutoff = material.alphaTest;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// doubleSided\n\t\t\t\t\tif ( material.side === THREE.DoubleSide ) {\n\n\t\t\t\t\t\tgltfMaterial.doubleSided = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( material.name !== '' ) {\n\n\t\t\t\t\t\tgltfMaterial.name = material.name;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( Object.keys( material.userData ).length > 0 ) {\n\n\t\t\t\t\t\tgltfMaterial.extras = serializeUserData( material );\n\n\t\t\t\t\t}\n\n\t\t\t\t\toutputJSON.materials.push( gltfMaterial );\n\n\t\t\t\t\tvar index = outputJSON.materials.length - 1;\n\t\t\t\t\tcachedData.materials.set( material, index );\n\n\t\t\t\t\treturn index;\n\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * Process mesh\n\t\t\t\t * \n\t\t\t\t * @param {THREE.Mesh}\n\t\t\t\t *            mesh Mesh to process\n\t\t\t\t * @return {Integer} Index of the processed mesh in the \"meshes\"\n\t\t\t\t *         array\n\t\t\t\t */\n\t\t\t\tfunction processMesh( mesh ) {\n\n\t\t\t\t\tvar geometry = mesh.geometry;\n\n\t\t\t\t\tvar mode;\n\n\t\t\t\t\t// Use the correct mode\n\t\t\t\t\tif ( mesh.isLineSegments ) {\n\n\t\t\t\t\t\tmode = WEBGL_CONSTANTS.LINES;\n\n\t\t\t\t\t} else if ( mesh.isLineLoop ) {\n\n\t\t\t\t\t\tmode = WEBGL_CONSTANTS.LINE_LOOP;\n\n\t\t\t\t\t} else if ( mesh.isLine ) {\n\n\t\t\t\t\t\tmode = WEBGL_CONSTANTS.LINE_STRIP;\n\n\t\t\t\t\t} else if ( mesh.isPoints ) {\n\n\t\t\t\t\t\tmode = WEBGL_CONSTANTS.POINTS;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( ! geometry.isBufferGeometry ) {\n\n\t\t\t\t\t\t\tvar geometryTemp = new THREE.BufferGeometry();\n\t\t\t\t\t\t\tgeometryTemp.fromGeometry( geometry );\n\t\t\t\t\t\t\tgeometry = geometryTemp;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( mesh.drawMode === THREE.TriangleFanDrawMode ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'GLTFExporter: TriangleFanDrawMode and wireframe incompatible.' );\n\t\t\t\t\t\t\tmode = WEBGL_CONSTANTS.TRIANGLE_FAN;\n\n\t\t\t\t\t\t} else if ( mesh.drawMode === THREE.TriangleStripDrawMode ) {\n\n\t\t\t\t\t\t\tmode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINE_STRIP : WEBGL_CONSTANTS.TRIANGLE_STRIP;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tmode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar gltfMesh = {};\n\n\t\t\t\t\tvar attributes = {};\n\t\t\t\t\tvar primitives = [];\n\t\t\t\t\tvar targets = [];\n\n\t\t\t\t\t// Conversion between attributes names in threejs and gltf\n\t\t\t\t\t// spec\n\t\t\t\t\tvar nameConversion = {\n\n\t\t\t\t\t\t\tuv: 'TEXCOORD_0',\n\t\t\t\t\t\t\tuv2: 'TEXCOORD_1',\n\t\t\t\t\t\t\tcolor: 'COLOR_0',\n\t\t\t\t\t\t\tskinWeight: 'WEIGHTS_0',\n\t\t\t\t\t\t\tskinIndex: 'JOINTS_0'\n\n\t\t\t\t\t};\n\n\t\t\t\t\tvar originalNormal = geometry.getAttribute( 'normal' );\n\n\t\t\t\t\tif ( originalNormal !== undefined && ! isNormalizedNormalAttribute( originalNormal ) ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.' );\n\n\t\t\t\t\t\tgeometry.addAttribute( 'normal', createNormalizedNormalAttribute( originalNormal ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// @QUESTION Detect if .vertexColors = THREE.VertexColors?\n\t\t\t\t\t// For every attribute create an accessor\n\t\t\t\t\tfor ( var attributeName in geometry.attributes ) {\n\n\t\t\t\t\t\tvar attribute = geometry.attributes[ attributeName ];\n\t\t\t\t\t\tattributeName = nameConversion[ attributeName ] || attributeName.toUpperCase();\n\n\t\t\t\t\t\t// JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT.\n\t\t\t\t\t\tvar array = attribute.array;\n\t\t\t\t\t\tif ( attributeName === 'JOINTS_0' &&\n\t\t\t\t\t\t\t\t! ( array instanceof Uint16Array ) &&\n\t\t\t\t\t\t\t\t! ( array instanceof Uint8Array ) ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.' );\n\t\t\t\t\t\t\tattribute = new THREE.BufferAttribute( new Uint16Array( array ), attribute.itemSize, attribute.normalized );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( attributeName.substr( 0, 5 ) !== 'MORPH' ) {\n\n\t\t\t\t\t\t\tvar accessor = processAccessor( attribute, geometry );\n\t\t\t\t\t\t\tif ( accessor !== null ) {\n\n\t\t\t\t\t\t\t\tattributes[ attributeName ] = accessor;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( originalNormal !== undefined ) geometry.addAttribute( 'normal', originalNormal );\n\n\t\t\t\t\t// Skip if no exportable attributes found\n\t\t\t\t\tif ( Object.keys( attributes ).length === 0 ) {\n\n\t\t\t\t\t\treturn null;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Morph targets\n\t\t\t\t\tif ( mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0 ) {\n\n\t\t\t\t\t\tvar weights = [];\n\t\t\t\t\t\tvar targetNames = [];\n\t\t\t\t\t\tvar reverseDictionary = {};\n\n\t\t\t\t\t\tif ( mesh.morphTargetDictionary !== undefined ) {\n\n\t\t\t\t\t\t\tfor ( var key in mesh.morphTargetDictionary ) {\n\n\t\t\t\t\t\t\t\treverseDictionary[ mesh.morphTargetDictionary[ key ] ] = key;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor ( var i = 0; i < mesh.morphTargetInfluences.length; ++ i ) {\n\n\t\t\t\t\t\t\tvar target = {};\n\n\t\t\t\t\t\t\tvar warned = false;\n\n\t\t\t\t\t\t\tfor ( var attributeName in geometry.morphAttributes ) {\n\n\t\t\t\t\t\t\t\t// glTF 2.0 morph supports only\n\t\t\t\t\t\t\t\t// POSITION/NORMAL/TANGENT.\n\t\t\t\t\t\t\t\t// Three.js doesn't support TANGENT yet.\n\n\t\t\t\t\t\t\t\tif ( attributeName !== 'position' && attributeName !== 'normal' ) {\n\n\t\t\t\t\t\t\t\t\tif ( ! warned ) {\n\n\t\t\t\t\t\t\t\t\t\tconsole.warn( 'GLTFExporter: Only POSITION and NORMAL morph are supported.' );\n\t\t\t\t\t\t\t\t\t\twarned = true;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tvar attribute = geometry.morphAttributes[ attributeName ][ i ];\n\n\t\t\t\t\t\t\t\t// Three.js morph attribute has absolute values\n\t\t\t\t\t\t\t\t// while the one of glTF has relative values.\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t// glTF 2.0 Specification:\n\t\t\t\t\t\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets\n\n\t\t\t\t\t\t\t\tvar baseAttribute = geometry.attributes[ attributeName ];\n\t\t\t\t\t\t\t\t// Clones attribute not to override\n\t\t\t\t\t\t\t\tvar relativeAttribute = attribute.clone();\n\n\t\t\t\t\t\t\t\tfor ( var j = 0, jl = attribute.count; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\t\t\trelativeAttribute.setXYZ(\n\t\t\t\t\t\t\t\t\t\t\tj,\n\t\t\t\t\t\t\t\t\t\t\tattribute.getX( j ) - baseAttribute.getX( j ),\n\t\t\t\t\t\t\t\t\t\t\tattribute.getY( j ) - baseAttribute.getY( j ),\n\t\t\t\t\t\t\t\t\t\t\tattribute.getZ( j ) - baseAttribute.getZ( j )\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\ttarget[ attributeName.toUpperCase() ] = processAccessor( relativeAttribute, geometry );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ttargets.push( target );\n\n\t\t\t\t\t\t\tweights.push( mesh.morphTargetInfluences[ i ] );\n\t\t\t\t\t\t\tif ( mesh.morphTargetDictionary !== undefined ) targetNames.push( reverseDictionary[ i ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgltfMesh.weights = weights;\n\n\t\t\t\t\t\tif ( targetNames.length > 0 ) {\n\n\t\t\t\t\t\t\tgltfMesh.extras = {};\n\t\t\t\t\t\t\tgltfMesh.extras.targetNames = targetNames;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar extras = ( Object.keys( geometry.userData ).length > 0 ) ? serializeUserData( geometry ) : undefined;\n\n\t\t\t\t\tvar forceIndices = options.forceIndices;\n\t\t\t\t\tvar isMultiMaterial = Array.isArray( mesh.material );\n\n\t\t\t\t\tif ( isMultiMaterial && geometry.groups.length === 0 ) return null;\n\n\t\t\t\t\tif ( ! forceIndices && geometry.index === null && isMultiMaterial ) {\n\n\t\t\t\t\t\t// temporal workaround.\n\t\t\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Creating index for non-indexed multi-material mesh.' );\n\t\t\t\t\t\tforceIndices = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar didForceIndices = false;\n\n\t\t\t\t\tif ( geometry.index === null && forceIndices ) {\n\n\t\t\t\t\t\tvar indices = [];\n\n\t\t\t\t\t\tfor ( var i = 0, il = geometry.attributes.position.count; i < il; i ++ ) {\n\n\t\t\t\t\t\t\tindices[ i ] = i;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgeometry.setIndex( indices );\n\n\t\t\t\t\t\tdidForceIndices = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar materials = isMultiMaterial ? mesh.material : [ mesh.material ];\n\t\t\t\t\tvar groups = isMultiMaterial ? geometry.groups : [ { materialIndex: 0, start: undefined, count: undefined } ];\n\n\t\t\t\t\tfor ( var i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tvar primitive = {\n\t\t\t\t\t\t\t\tmode: mode,\n\t\t\t\t\t\t\t\tattributes: attributes,\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tif ( extras ) primitive.extras = extras;\n\n\t\t\t\t\t\tif ( targets.length > 0 ) primitive.targets = targets;\n\n\t\t\t\t\t\tif ( geometry.index !== null ) {\n\n\t\t\t\t\t\t\tprimitive.indices = processAccessor( geometry.index, geometry, groups[ i ].start, groups[ i ].count );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar material = processMaterial( materials[ groups[ i ].materialIndex ] );\n\n\t\t\t\t\t\tif ( material !== null ) {\n\n\t\t\t\t\t\t\tprimitive.material = material;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tprimitives.push( primitive );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( didForceIndices ) {\n\n\t\t\t\t\t\tgeometry.setIndex( null );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgltfMesh.primitives = primitives;\n\n\t\t\t\t\tif ( ! outputJSON.meshes ) {\n\n\t\t\t\t\t\toutputJSON.meshes = [];\n\n\t\t\t\t\t}\n\n\t\t\t\t\toutputJSON.meshes.push( gltfMesh );\n\n\t\t\t\t\treturn outputJSON.meshes.length - 1;\n\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * Process camera\n\t\t\t\t * \n\t\t\t\t * @param {THREE.Camera}\n\t\t\t\t *            camera Camera to process\n\t\t\t\t * @return {Integer} Index of the processed mesh in the \"camera\"\n\t\t\t\t *         array\n\t\t\t\t */\n\t\t\t\tfunction processCamera( camera ) {\n\n\t\t\t\t\tif ( ! outputJSON.cameras ) {\n\n\t\t\t\t\t\toutputJSON.cameras = [];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar isOrtho = camera.isOrthographicCamera;\n\n\t\t\t\t\tvar gltfCamera = {\n\n\t\t\t\t\t\t\ttype: isOrtho ? 'orthographic' : 'perspective'\n\n\t\t\t\t\t};\n\n\t\t\t\t\tif ( isOrtho ) {\n\n\t\t\t\t\t\tgltfCamera.orthographic = {\n\n\t\t\t\t\t\t\t\txmag: camera.right * 2,\n\t\t\t\t\t\t\t\tymag: camera.top * 2,\n\t\t\t\t\t\t\t\tzfar: camera.far <= 0 ? 0.001 : camera.far,\n\t\t\t\t\t\t\t\t\t\tznear: camera.near < 0 ? 0 : camera.near\n\n\t\t\t\t\t\t};\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgltfCamera.perspective = {\n\n\t\t\t\t\t\t\t\taspectRatio: camera.aspect,\n\t\t\t\t\t\t\t\tyfov: THREE.Math.degToRad( camera.fov ) / camera.aspect,\n\t\t\t\t\t\t\t\tzfar: camera.far <= 0 ? 0.001 : camera.far,\n\t\t\t\t\t\t\t\t\t\tznear: camera.near < 0 ? 0 : camera.near\n\n\t\t\t\t\t\t};\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( camera.name !== '' ) {\n\n\t\t\t\t\t\tgltfCamera.name = camera.type;\n\n\t\t\t\t\t}\n\n\t\t\t\t\toutputJSON.cameras.push( gltfCamera );\n\n\t\t\t\t\treturn outputJSON.cameras.length - 1;\n\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * Creates glTF animation entry from AnimationClip object.\n\t\t\t\t * \n\t\t\t\t * Status: - Only properties listed in PATH_PROPERTIES may be\n\t\t\t\t * animated.\n\t\t\t\t * \n\t\t\t\t * @param {THREE.AnimationClip}\n\t\t\t\t *            clip\n\t\t\t\t * @param {THREE.Object3D}\n\t\t\t\t *            root\n\t\t\t\t * @return {number}\n\t\t\t\t */\n\t\t\t\tfunction processAnimation( clip, root ) {\n\n\t\t\t\t\tif ( ! outputJSON.animations ) {\n\n\t\t\t\t\t\toutputJSON.animations = [];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar channels = [];\n\t\t\t\t\tvar samplers = [];\n\n\t\t\t\t\tfor ( var i = 0; i < clip.tracks.length; ++ i ) {\n\n\t\t\t\t\t\tvar track = clip.tracks[ i ];\n\t\t\t\t\t\tvar trackBinding = THREE.PropertyBinding.parseTrackName( track.name );\n\t\t\t\t\t\tvar trackNode = THREE.PropertyBinding.findNode( root, trackBinding.nodeName );\n\t\t\t\t\t\tvar trackProperty = PATH_PROPERTIES[ trackBinding.propertyName ];\n\n\t\t\t\t\t\tif ( trackBinding.objectName === 'bones' ) {\n\n\t\t\t\t\t\t\tif ( trackNode.isSkinnedMesh === true ) {\n\n\t\t\t\t\t\t\t\ttrackNode = trackNode.skeleton.getBoneByName( trackBinding.objectIndex );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\ttrackNode = undefined;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( ! trackNode || ! trackProperty ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Could not export animation track \"%s\".', track.name );\n\t\t\t\t\t\t\treturn null;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar inputItemSize = 1;\n\t\t\t\t\t\tvar outputItemSize = track.values.length / track.times.length;\n\n\t\t\t\t\t\tif ( trackProperty === PATH_PROPERTIES.morphTargetInfluences ) {\n\n\t\t\t\t\t\t\tif ( trackNode.morphTargetInfluences.length !== 1 &&\n\t\t\t\t\t\t\t\t\ttrackBinding.propertyIndex !== undefined ) {\n\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Skipping animation track \"%s\". ' +\n\t\t\t\t\t\t\t\t\t\t'Morph target keyframe tracks must target all available morph targets ' +\n\t\t\t\t\t\t\t\t\t\t'for the given mesh.', track.name );\n\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\toutputItemSize /= trackNode.morphTargetInfluences.length;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar interpolation;\n\n\t\t\t\t\t\t// @TODO export CubicInterpolant(InterpolateSmooth) as\n\t\t\t\t\t\t// CUBICSPLINE\n\n\t\t\t\t\t\t// Detecting glTF cubic spline interpolant by checking\n\t\t\t\t\t\t// factory method's special property\n\t\t\t\t\t\t// GLTFCubicSplineInterpolant is a custom interpolant\n\t\t\t\t\t\t// and track doesn't return\n\t\t\t\t\t\t// valid value from .getInterpolation().\n\t\t\t\t\t\tif ( track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true ) {\n\n\t\t\t\t\t\t\tinterpolation = 'CUBICSPLINE';\n\n\t\t\t\t\t\t\t// itemSize of CUBICSPLINE keyframe is 9\n\t\t\t\t\t\t\t// (VEC3 * 3: inTangent, splineVertex, and\n\t\t\t\t\t\t\t// outTangent)\n\t\t\t\t\t\t\t// but needs to be stored as VEC3 so dividing by 3\n\t\t\t\t\t\t\t// here.\n\t\t\t\t\t\t\toutputItemSize /= 3;\n\n\t\t\t\t\t\t} else if ( track.getInterpolation() === THREE.InterpolateDiscrete ) {\n\n\t\t\t\t\t\t\tinterpolation = 'STEP';\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tinterpolation = 'LINEAR';\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tsamplers.push( {\n\n\t\t\t\t\t\t\tinput: processAccessor( new THREE.BufferAttribute( track.times, inputItemSize ) ),\n\t\t\t\t\t\t\toutput: processAccessor( new THREE.BufferAttribute( track.values, outputItemSize ) ),\n\t\t\t\t\t\t\tinterpolation: interpolation\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\tchannels.push( {\n\n\t\t\t\t\t\t\tsampler: samplers.length - 1,\n\t\t\t\t\t\t\ttarget: {\n\t\t\t\t\t\t\t\tnode: nodeMap.get( trackNode ),\n\t\t\t\t\t\t\t\tpath: trackProperty\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t\toutputJSON.animations.push( {\n\n\t\t\t\t\t\tname: clip.name || 'clip_' + outputJSON.animations.length,\n\t\t\t\t\t\tsamplers: samplers,\n\t\t\t\t\t\tchannels: channels\n\n\t\t\t\t\t} );\n\n\t\t\t\t\treturn outputJSON.animations.length - 1;\n\n\t\t\t\t}\n\n\t\t\t\tfunction processSkin( object ) {\n\n\t\t\t\t\tvar node = outputJSON.nodes[ nodeMap.get( object ) ];\n\n\t\t\t\t\tvar skeleton = object.skeleton;\n\t\t\t\t\tvar rootJoint = object.skeleton.bones[ 0 ];\n\n\t\t\t\t\tif ( rootJoint === undefined ) return null;\n\n\t\t\t\t\tvar joints = [];\n\t\t\t\t\tvar inverseBindMatrices = new Float32Array( skeleton.bones.length * 16 );\n\n\t\t\t\t\tfor ( var i = 0; i < skeleton.bones.length; ++ i ) {\n\n\t\t\t\t\t\tjoints.push( nodeMap.get( skeleton.bones[ i ] ) );\n\n\t\t\t\t\t\tskeleton.boneInverses[ i ].toArray( inverseBindMatrices, i * 16 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( outputJSON.skins === undefined ) {\n\n\t\t\t\t\t\toutputJSON.skins = [];\n\n\t\t\t\t\t}\n\n\t\t\t\t\toutputJSON.skins.push( {\n\n\t\t\t\t\t\tinverseBindMatrices: processAccessor( new THREE.BufferAttribute( inverseBindMatrices, 16 ) ),\n\t\t\t\t\t\tjoints: joints,\n\t\t\t\t\t\tskeleton: nodeMap.get( rootJoint )\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tvar skinIndex = node.skin = outputJSON.skins.length - 1;\n\n\t\t\t\t\treturn skinIndex;\n\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * Process Object3D node\n\t\t\t\t * \n\t\t\t\t * @param {THREE.Object3D}\n\t\t\t\t *            node Object3D to processNode\n\t\t\t\t * @return {Integer} Index of the node in the nodes list\n\t\t\t\t */\n\t\t\t\tfunction processNode( object ) {\n\n\t\t\t\t\tif ( object.isLight ) {\n\n\t\t\t\t\t\tconsole.warn( 'GLTFExporter: Unsupported node type:', object.constructor.name );\n\t\t\t\t\t\treturn null;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! outputJSON.nodes ) {\n\n\t\t\t\t\t\toutputJSON.nodes = [];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar gltfNode = {};\n\n\t\t\t\t\tif ( options.trs ) {\n\n\t\t\t\t\t\tvar rotation = object.quaternion.toArray();\n\t\t\t\t\t\tvar position = object.position.toArray();\n\t\t\t\t\t\tvar scale = object.scale.toArray();\n\n\t\t\t\t\t\tif ( ! equalArray( rotation, [ 0, 0, 0, 1 ] ) ) {\n\n\t\t\t\t\t\t\tgltfNode.rotation = rotation;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( ! equalArray( position, [ 0, 0, 0 ] ) ) {\n\n\t\t\t\t\t\t\tgltfNode.translation = position;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( ! equalArray( scale, [ 1, 1, 1 ] ) ) {\n\n\t\t\t\t\t\t\tgltfNode.scale = scale;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tobject.updateMatrix();\n\t\t\t\t\t\tif ( ! equalArray( object.matrix.elements, [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ] ) ) {\n\n\t\t\t\t\t\t\tgltfNode.matrix = object.matrix.elements;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// We don't export empty strings name because it represents\n\t\t\t\t\t// no-name in Three.js.\n\t\t\t\t\tif ( object.name !== '' ) {\n\n\t\t\t\t\t\tgltfNode.name = String( object.name );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( object.userData && Object.keys( object.userData ).length > 0 ) {\n\n\t\t\t\t\t\tgltfNode.extras = serializeUserData( object );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( object.isMesh || object.isLine || object.isPoints ) {\n\n\t\t\t\t\t\tvar mesh = processMesh( object );\n\n\t\t\t\t\t\tif ( mesh !== null ) {\n\n\t\t\t\t\t\t\tgltfNode.mesh = mesh;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( object.isCamera ) {\n\n\t\t\t\t\t\tgltfNode.camera = processCamera( object );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\t\t\t\tskins.push( object );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( object.children.length > 0 ) {\n\n\t\t\t\t\t\tvar children = [];\n\n\t\t\t\t\t\tfor ( var i = 0, l = object.children.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tvar child = object.children[ i ];\n\n\t\t\t\t\t\t\tif ( child.visible || options.onlyVisible === false ) {\n\n\t\t\t\t\t\t\t\tvar node = processNode( child );\n\n\t\t\t\t\t\t\t\tif ( node !== null ) {\n\n\t\t\t\t\t\t\t\t\tchildren.push( node );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( children.length > 0 ) {\n\n\t\t\t\t\t\t\tgltfNode.children = children;\n\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t}\n\n\t\t\t\t\toutputJSON.nodes.push( gltfNode );\n\n\t\t\t\t\tvar nodeIndex = outputJSON.nodes.length - 1;\n\t\t\t\t\tnodeMap.set( object, nodeIndex );\n\n\t\t\t\t\treturn nodeIndex;\n\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * Process Scene\n\t\t\t\t * \n\t\t\t\t * @param {THREE.Scene}\n\t\t\t\t *            node Scene to process\n\t\t\t\t */\n\t\t\t\tfunction processScene( scene ) {\n\n\t\t\t\t\tif ( ! outputJSON.scenes ) {\n\n\t\t\t\t\t\toutputJSON.scenes = [];\n\t\t\t\t\t\toutputJSON.scene = 0;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar gltfScene = {\n\n\t\t\t\t\t\t\tnodes: []\n\n\t\t\t\t\t};\n\n\t\t\t\t\tif ( scene.name !== '' ) {\n\n\t\t\t\t\t\tgltfScene.name = scene.name;\n\n\t\t\t\t\t}\n\n\t\t\t\t\toutputJSON.scenes.push( gltfScene );\n\n\t\t\t\t\tvar nodes = [];\n\n\t\t\t\t\tfor ( var i = 0, l = scene.children.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tvar child = scene.children[ i ];\n\n\t\t\t\t\t\tif ( child.visible || options.onlyVisible === false ) {\n\n\t\t\t\t\t\t\tvar node = processNode( child );\n\n\t\t\t\t\t\t\tif ( node !== null ) {\n\n\t\t\t\t\t\t\t\tnodes.push( node );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( nodes.length > 0 ) {\n\n\t\t\t\t\t\tgltfScene.nodes = nodes;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * Creates a THREE.Scene to hold a list of objects and parse it\n\t\t\t\t * \n\t\t\t\t * @param {Array}\n\t\t\t\t *            objects List of objects to process\n\t\t\t\t */\n\t\t\t\tfunction processObjects( objects ) {\n\n\t\t\t\t\tvar scene = new THREE.Scene();\n\t\t\t\t\tscene.name = 'AuxScene';\n\n\t\t\t\t\tfor ( var i = 0; i < objects.length; i ++ ) {\n\n\t\t\t\t\t\t// We push directly to children instead of calling `add`\n\t\t\t\t\t\t// to prevent\n\t\t\t\t\t\t// modify the .parent and break its original scene and\n\t\t\t\t\t\t// hierarchy\n\t\t\t\t\t\tscene.children.push( objects[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tprocessScene( scene );\n\n\t\t\t\t}\n\n\t\t\t\tfunction processInput( input ) {\n\n\t\t\t\t\tinput = input instanceof Array ? input : [ input ];\n\n\t\t\t\t\tvar objectsWithoutScene = [];\n\n\t\t\t\t\tfor ( var i = 0; i < input.length; i ++ ) {\n\n\t\t\t\t\t\tif ( input[ i ] instanceof THREE.Scene ) {\n\n\t\t\t\t\t\t\tprocessScene( input[ i ] );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tobjectsWithoutScene.push( input[ i ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( objectsWithoutScene.length > 0 ) {\n\n\t\t\t\t\t\tprocessObjects( objectsWithoutScene );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var i = 0; i < skins.length; ++ i ) {\n\n\t\t\t\t\t\tprocessSkin( skins[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var i = 0; i < options.animations.length; ++ i ) {\n\n\t\t\t\t\t\tprocessAnimation( options.animations[ i ], input[ 0 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tprocessInput( input );\n\n\t\t\t\tPromise.all( pending ).then( function () {\n\n\t\t\t\t\t// Merge buffers.\n\t\t\t\t\tvar blob = new Blob( buffers, { type: 'application/octet-stream' } );\n\n\t\t\t\t\t// Declare extensions.\n\t\t\t\t\tvar extensionsUsedList = Object.keys( extensionsUsed );\n\t\t\t\t\tif ( extensionsUsedList.length > 0 ) outputJSON.extensionsUsed = extensionsUsedList;\n\n\t\t\t\t\tif ( outputJSON.buffers && outputJSON.buffers.length > 0 ) {\n\n\t\t\t\t\t\t// Update bytelength of the single buffer.\n\t\t\t\t\t\toutputJSON.buffers[ 0 ].byteLength = blob.size;\n\n\t\t\t\t\t\tvar reader = new window.FileReader();\n\n\t\t\t\t\t\tif ( options.binary === true ) {\n\n\t\t\t\t\t\t\t// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\n\t\t\t\t\t\t\tvar GLB_HEADER_BYTES = 12;\n\t\t\t\t\t\t\tvar GLB_HEADER_MAGIC = 0x46546C67;\n\t\t\t\t\t\t\tvar GLB_VERSION = 2;\n\n\t\t\t\t\t\t\tvar GLB_CHUNK_PREFIX_BYTES = 8;\n\t\t\t\t\t\t\tvar GLB_CHUNK_TYPE_JSON = 0x4E4F534A;\n\t\t\t\t\t\t\tvar GLB_CHUNK_TYPE_BIN = 0x004E4942;\n\n\t\t\t\t\t\t\treader.readAsArrayBuffer( blob );\n\t\t\t\t\t\t\treader.onloadend = function () {\n\n\t\t\t\t\t\t\t\t// Binary chunk.\n\t\t\t\t\t\t\t\tvar binaryChunk = getPaddedArrayBuffer( reader.result );\n\t\t\t\t\t\t\t\tvar binaryChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );\n\t\t\t\t\t\t\t\tbinaryChunkPrefix.setUint32( 0, binaryChunk.byteLength, true );\n\t\t\t\t\t\t\t\tbinaryChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_BIN, true );\n\n\t\t\t\t\t\t\t\t// JSON chunk.\n\t\t\t\t\t\t\t\tvar jsonChunk = getPaddedArrayBuffer( stringToArrayBuffer( JSON.stringify( outputJSON ) ), 0x20 );\n\t\t\t\t\t\t\t\tvar jsonChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );\n\t\t\t\t\t\t\t\tjsonChunkPrefix.setUint32( 0, jsonChunk.byteLength, true );\n\t\t\t\t\t\t\t\tjsonChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_JSON, true );\n\n\t\t\t\t\t\t\t\t// GLB header.\n\t\t\t\t\t\t\t\tvar header = new ArrayBuffer( GLB_HEADER_BYTES );\n\t\t\t\t\t\t\t\tvar headerView = new DataView( header );\n\t\t\t\t\t\t\t\theaderView.setUint32( 0, GLB_HEADER_MAGIC, true );\n\t\t\t\t\t\t\t\theaderView.setUint32( 4, GLB_VERSION, true );\n\t\t\t\t\t\t\t\tvar totalByteLength = GLB_HEADER_BYTES\n\t\t\t\t\t\t\t\t+ jsonChunkPrefix.byteLength + jsonChunk.byteLength\n\t\t\t\t\t\t\t\t+ binaryChunkPrefix.byteLength + binaryChunk.byteLength;\n\t\t\t\t\t\t\t\theaderView.setUint32( 8, totalByteLength, true );\n\n\t\t\t\t\t\t\t\tvar glbBlob = new Blob( [\n\t\t\t\t\t\t\t\t\theader,\n\t\t\t\t\t\t\t\t\tjsonChunkPrefix,\n\t\t\t\t\t\t\t\t\tjsonChunk,\n\t\t\t\t\t\t\t\t\tbinaryChunkPrefix,\n\t\t\t\t\t\t\t\t\tbinaryChunk\n\t\t\t\t\t\t\t\t\t], { type: 'application/octet-stream' } );\n\n\t\t\t\t\t\t\t\tvar glbReader = new window.FileReader();\n\t\t\t\t\t\t\t\tglbReader.readAsArrayBuffer( glbBlob );\n\t\t\t\t\t\t\t\tglbReader.onloadend = function () {\n\n\t\t\t\t\t\t\t\t\tonDone( glbReader.result );\n\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\treader.readAsDataURL( blob );\n\t\t\t\t\t\t\treader.onloadend = function () {\n\n\t\t\t\t\t\t\t\tvar base64data = reader.result;\n\t\t\t\t\t\t\t\toutputJSON.buffers[ 0 ].uri = base64data;\n\t\t\t\t\t\t\t\tonDone( outputJSON );\n\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tonDone( outputJSON );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\t\t\t}\n\t};\n\treturn GLTFExporter;\n})();\nmodule.exports = _GLTFExporter;\n"],
  "mappings": "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",
  "names": ["input"]
}
